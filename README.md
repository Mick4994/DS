# DS-Triangle-mesh-Gobang
This is the homework of Data Structure lesson

主要工作：
1. 设置了棋盘初始状态时的可落子的点，也给出了二维数组下标与xyz坐标之间的转换
    棋盘是一个29*15的二维数组，但是实际棋盘的形状是正六边形的，所以需要设置好棋盘可落子的点，可落子的点初始状态设置为0，否则为-1。
    根据规律找出棋盘的点：
    0行到7行，列的循环条件为for (int cel = 7 - row; cel <= 7 + row; cel += 2)；
    8行到21行： 列的循环条件为for (int cel = (row + 1) % 2; cel <= 14; cel += 2)；
    22行到28行： 列的循环条件为for (int cel = row - 21; cel <= 35 - row; cel += 2)。
    二维数组下标与xyz坐标之间的转换在BoardEvaluate.cpp文件里体现。
2. 编写了对棋盘进行估分的函数 （BoardEvaluate.cpp文件）
    首先定义五元组：六边形棋盘任意方向上连续相连的五个点称为五元组。对于整个棋盘的估分的思路就是把棋盘上所有五元组的估分加起来。
对于五元组的估分，设置如下：
   (1)同时含有黑子和白子，得0分;
   (2)含有1个子和4个空点，得1分;
   (3)含有2个子和3个空点，得10分;
   (4)含有3个子和2个空点，得100分;
   (5)含有4个子和1个空点，得10000分;
   (6)含有5个子，得1000000分
   (7)特殊情况，形如“0BBB0”，得2000分（B为黑子，0为无落子）
对于五元组估分函数，传参为棋盘和棋子的颜色，当五元组的元素与传入的棋子颜色不同时会返回0分。 
我把五元组的每个元素的状态划分为0和其他这两种状态，所以一个五元组共有2^5 = 32种可能，
使用哈夫曼树的思想，对32种可能事先进行编码计算，并存入一个长度为32的估分数组中，根据数组下标返回得分。
解码时，遍历一遍五元组的元素，使用满二叉树的性质5，设置一个变量数值为1，当遍历到的元素为0时，往左子树走，数值*2；否则往右子树走（如果棋子颜色不同直接返回0），数值*2+1。
遍历完成后，数值减去32即可得到估分数组的下标。这样就可以达到只遍历一遍五元组就可以返回得分的目的，算法时间复杂度达到了最小。
对于整个棋盘的估分函数：
运用到了循环队列的思想，设定3个长度为6的数组作为3个方向上的五元组的存储队列，数组的最后一个元素为队列起始位置的下标，前五个元素存储五元组的元素。
3.编写了AI下棋函数(AIChess)
   运用了博弈树和α-β剪枝极大极小搜索算法，通过修改深度n，来实现走一步，看n步的AI。
   算法具体流程如下：
   在aiMakeMove函数中，ai会对棋盘进行遍历，每次遍历会下一步棋并进行极大极小搜索来计算该点的最大收益。
   当达到算法规定递归深度时，叶子节点通过估分函数计算出该棋盘下的分数，并回溯给双亲节点。
   在极大极小搜索中，max层的α取孩子最大值，min层的β取孩子最小值，即max层只会修改α，min层只会修改β。双亲节点会将自己的α和β传递给孩子。当α>β时，则认为该分支下不再有更有解，进行剪枝。
   最后AI会记录下棋盘上某个最高分的点在该点并落子。
   
