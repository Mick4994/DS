# DS-Triangle-mesh-Gobang
This is the homework of Data Structure lesson

主要工作：
1. 设置了棋盘初始状态时的可落子的点，也给出了二维数组下标与xyz坐标之间的转换
    棋盘是一个29*15的二维数组，但是实际棋盘的形状是正六边形的，所以需要设置好棋盘可落子的点，可落子的点初始状态设置为0，否则为-1。
    根据规律找出棋盘的点：
    0行到7行，列的循环条件为for (int cel = 7 - row; cel <= 7 + row; cel += 2)；
    8行到21行： 列的循环条件为for (int cel = (row + 1) % 2; cel <= 14; cel += 2)；
    22行到28行： 列的循环条件为for (int cel = row - 21; cel <= 35 - row; cel += 2)。
    二维数组下标与xyz坐标之间的转换在BoardEvaluate.cpp文件里体现。
2. 编写了对棋盘进行估分的函数 （BoardEvaluate.cpp文件）
    首先定义五元组：六边形棋盘任意方向上连续相连的五个点称为五元组。对于整个棋盘的估分的思路就是把棋盘上所有五元组的估分加起来。
对于五元组的估分，设置如下：
   (1)同时含有黑子和白子，得0分;
   (2)含有1个子和4个空点，得1分;
   (3)含有2个子和3个空点，得10分;
   (4)含有3个子和2个空点，得100分;
   (5)含有4个子和1个空点，得10000分;
   (6)含有5个子，得1000000分
   (7)特殊情况，形如“0BBB0”，得2000分（B为黑子，0为无落子）
对于五元组估分函数，传参为棋盘和棋子的颜色，当五元组的元素与传入的棋子颜色不同时会返回0分。 
我把五元组的每个元素的状态划分为0和其他这两种状态，所以一个五元组共有2^5 = 32种可能，
使用哈夫曼树的思想，对32种可能事先进行编码计算，并存入一个长度为32的估分数组中，根据数组下标返回得分。
解码时，遍历一遍五元组的元素，使用满二叉树的性质5，设置一个变量数值为1，当遍历到的元素为0时，往左子树走，数值*2；否则往右子树走（如果棋子颜色不同直接返回0），数值*2+1。
遍历完成后，数值减去32即可得到估分数组的下标。这样就可以达到只遍历一遍五元组就可以返回得分的目的，算法时间复杂度达到了最小。
对于整个棋盘的估分函数：
运用到了循环队列的思想，设定3个长度为6的数组作为3个方向上的五元组的存储队列，数组的最后一个元素为队列起始位置的下标，前五个元素存储五元组的元素。

