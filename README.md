# DS-Triangle-mesh-Gobang
This is the homework of Data Structure lesson

主要工作：
1. 设置了棋盘初始状态时的可落子的点，也给出了二维数组下标与xyz坐标之间的转换
    棋盘是一个29*15的二维数组，但是实际棋盘的形状是正六边形的，所以需要设置好棋盘可落子的点，可落子的点初始状态设置为0，否则为-1。
    根据规律找出棋盘的点：
    0行到7行，列的循环条件为for (int cel = 7 - row; cel <= 7 + row; cel += 2)；
    8行到21行： 列的循环条件为for (int cel = (row + 1) % 2; cel <= 14; cel += 2)；
    22行到28行： 列的循环条件为for (int cel = row - 21; cel <= 35 - row; cel += 2)。
    二维数组下标与xyz坐标之间的转换在BoardEvaluate.cpp文件里体现。
2. 编写了对棋盘进行估分的函数 （BoardEvaluate.cpp文件）
    首先定义五元组：六边形棋盘任意方向上连续相连的五个点称为五元组。对于整个棋盘的估分的思路就是把棋盘上所有五元组的估分加起来。
对于五元组的估分，设置如下：
   (1)同时含有黑子和白子，得0分;
   (2)含有1个子和4个空点，得1分;
   (3)含有2个子和3个空点，得10分;
   (4)含有3个子和2个空点，得100分;
   (5)含有4个子和1个空点，得10000分;
   (6)含有5个子，得1000000分
   (7)特殊情况，形如“0BBB0”，得2000分（B为黑子，0为无落子）
对于五元组估分函数，传参为棋盘和棋子的颜色，当五元组的元素与传入的棋子颜色不同时会返回0分。 
我把五元组的每个元素的状态划分为0和其他这两种状态，所以一个五元组共有2^5 = 32种可能，
使用哈夫曼树的思想，对32种可能事先进行编码计算，并存入一个长度为32的估分数组中，根据数组下标返回得分。
解码时，遍历一遍五元组的元素，使用满二叉树的性质5，设置一个变量数值为1，当遍历到的元素为0时，往左子树走，数值*2；否则往右子树走（如果棋子颜色不同直接返回0），数值*2+1。
遍历完成后，数值减去32即可得到估分数组的下标。这样就可以达到只遍历一遍五元组就可以返回得分的目的，算法时间复杂度达到了最小。
对于整个棋盘的估分函数：
运用到了循环队列的思想，设定3个长度为6的数组作为3个方向上的五元组的存储队列，数组的最后一个元素为队列起始位置的下标，前五个元素存储五元组的元素。

3. 编写了AI下棋函数(AIChess)
   运用了博弈树和α-β剪枝极大极小搜索算法，通过修改深度n，来实现走一步，看n步的AI。
   算法具体流程如下：
   在aiMakeMove函数中，ai会对棋盘进行遍历，每次遍历会下一步棋并进行极大极小搜索来计算该点的最大收益。
   当达到算法规定递归深度时，叶子节点通过估分函数计算出该棋盘下的分数，并回溯给双亲节点。
   在极大极小搜索中，max层的α取孩子最大值，min层的β取孩子最小值，即max层只会修改α，min层只会修改β。双亲节点会将自己的α和β传递给孩子。当α>β时，则认为该分支下不再有更有解，进行剪枝。
   最后AI会记录下棋盘上某个最高分的点在该点并落子。

4. 编写了棋局胜利判断的一些函数(JudgeWin.cpp)
- JudgeWin.h 和JudgeWin.cpp文件中定义了一些函数和常量，用于判断六边形棋盘上是否有一方达到了五子连珠的条件，以获得游戏的胜利。
- 为了判断五子连珠，需要考虑六边形棋盘上的三个方向：x方向（水平），y方向（左上到右下），z方向（右上到左下）。 
- 对于每个方向，需要找出落子所在的线的编号，以及该线上的遍历起点坐标和遍历长度。这些信息可以通过一些数学公式或规律来计算。
- 然后，对于每个方向上的线，从起点开始遍历每个点，记录当前连续相同颜色棋子的个数。如果遇到不同颜色或空点，则清零计数器。如果计数器达到5，则说明有一方获胜，返回该颜色。
- 如果三个方向都没有达到五子连珠，则返回0，表示继续游戏。

在JudgeWin.cpp文件中：
- 包含JudgeWin.h文件和ChessBoardUI.h文件。
- 定义一个函数getLine_x来根据落子坐标计算x方向上的线编号，返回值为cel（列号）。
- 定义一个函数getLine_y来根据落子坐标计算y方向上的线编号，返回值为(row + cel - 7) / 2（行号加列号减7再除以2）。
- 定义一个函数getLine_z来根据落子坐标计算z方向上的线编号，返回值为abs(row - cel + 7) / 2（行号减列号加7再取绝对值再除以2）。
- 定义一个函数JudgeWin来判断落子方是否胜利，参数为棋盘和落子坐标，返回值为游戏状态：
    - 调用getLine_x，getLine_y，getLine_z函数来获取x，y，z方向上的线编号，并分别赋值给Line_x，Line_y，Line_z变量。
    - 根据线编号和一些规律来计算x，y，z方向上的遍历起点坐标和遍历长度，并分别赋值给start_row_x，start_cel_x，len_x等变量。
    - 获取当前落子的颜色，并赋值给color变量。
    - 对于每个方向：
        - 初始化一个计数器max_x等变量为0。
        - 用一个循环来遍历该方向上的线上的每个点：
            - 获取当前点的颜色，并赋值给cur_color变量。
            - 如果cur_color与color相同，则计数器加一。
            - 如果cur_color与color不同或为空，则计数器归零。
            - 如果计数器达到5，则返回color。
    - 如果三个方向都没有返回color，则返回0。
- 定义一个函数PrintJudgeWin来打印胜负结果，参数为棋盘和落子坐标，引用传递一个res变量来存储游戏状态：
    - 调用JudgeWin函数来获取游戏状态，并赋值给res变量。
    - 如果res为CONTINUE，则判断棋盘是否已满，如果是，则打印"Drawn game"，并调用StopGame函数；如果不是，则打印"Continue"。
    - 如果res为WHITE_WIN，则打印"White win"，并调用StopGame函数。
    - 如果res为BLACK_WIN，则打印"Black win"，并调用StopGame函数。
    - 调用DrawRes函数来在UI上显示胜负结果。
- 定义一个函数StopGame来停止游戏，并将棋盘上所有点的状态设为-1，参数为棋盘：
    - 用两个循环来遍历棋盘上的每个点，将其状态设为-1。
    - 将ChessBoard类的静态成员变量end设为true，表示游戏结束。